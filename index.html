<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Kinetic: DEBUGGER EDITION</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        /* START SCREEN */
        #splash {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #start-btn {
            padding: 20px 40px; font-size: 20px; background: #00ff00; border: none;
            cursor: pointer; font-weight: bold; letter-spacing: 2px;
            box-shadow: 0 0 20px #00ff00;
        }

        /* DEBUG DATA PANEL (Top Left) */
        #debug-panel {
            position: absolute; top: 20px; left: 20px; z-index: 100;
            background: rgba(0, 50, 0, 0.8); border: 1px solid #00ff00;
            color: #00ff00; padding: 15px; width: 250px; font-size: 12px;
            pointer-events: none;
        }
        .debug-row { display: flex; justify-content: space-between; margin-bottom: 5px; border-bottom: 1px solid #004400; }
        .val { font-weight: bold; color: white; }

        /* CONTROLS (Top Right) */
        #controls {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            display: flex; gap: 10px;
        }
        button {
            background: #222; color: white; border: 1px solid #555; padding: 10px 20px; cursor: pointer;
        }
        button:hover { background: #00ffff; color: black; }

        /* VISUAL MARKERS */
        #hand-marker {
            position: absolute; width: 40px; height: 40px;
            border: 4px solid #ff0000; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            display: none; z-index: 50;
        }
        
        /* Hidden Video */
        #input-video { position: absolute; opacity: 0; pointer-events: none; }
        #canvas-container { position: absolute; top:0; left:0; width:100%; height:100%; }
    </style>
</head>
<body>

    <div id="splash">
        <h1 style="color:white; margin-bottom:20px;">SYSTEM CHECK</h1>
        <button id="start-btn" onclick="startSystem()">START SYSTEM</button>
        <p style="color:#666; margin-top:10px;">Allow Camera Access when asked</p>
    </div>

    <div id="debug-panel">
        <div style="text-align:center; margin-bottom:10px; font-weight:bold;">DATA STREAM</div>
        <div class="debug-row"><span>STATUS:</span> <span id="d-status" class="val">WAITING</span></div>
        <div class="debug-row"><span>SOURCE:</span> <span id="d-source" class="val">NONE</span></div>
        <div class="debug-row"><span>HAND X:</span> <span id="d-x" class="val">0</span></div>
        <div class="debug-row"><span>HAND Y:</span> <span id="d-y" class="val">0</span></div>
        <div class="debug-row"><span>PINCH:</span> <span id="d-pinch" class="val">FALSE</span></div>
    </div>

    <div id="controls">
        <button onclick="setShape('globe')">Globe</button>
        <button onclick="setShape('heart')">Heart</button>
        <button onclick="setShape('saturn')">Saturn</button>
        <button onclick="setShape('helix')">Helix</button>
    </div>

    <div id="hand-marker"></div>
    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>

    <script>
        // Global Bridge to connect AI and Visuals
        window.BRIDGE = {
            active: false,
            x: 0,
            y: 0,
            pinch: false,
            setShape: null // Placeholder for Three.js function
        };

        function setShape(type) {
            if(window.BRIDGE.setShape) window.BRIDGE.setShape(type);
        }

        async function startSystem() {
            document.getElementById('splash').style.display = 'none';
            document.getElementById('d-status').innerText = "INITIALIZING...";
            
            // Start AI
            initAI();
            
            // Visuals start automatically via module
        }

        // --- AI LOGIC (Script Tag) ---
        async function initAI() {
            const videoElement = document.getElementById('input-video');
            const debugStatus = document.getElementById('d-status');

            try {
                if(!window.Hands) throw new Error("Library failed load");

                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                
                hands.setOptions({
                    maxNumHands: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => {
                    const marker = document.getElementById('hand-marker');
                    
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const lm = results.multiHandLandmarks[0];
                        
                        // 1. RAW COORDS (0 to 1)
                        // Mirror X for intuitive movement
                        const rawX = 1 - lm[9].x; 
                        const rawY = lm[9].y;

                        // 2. PINCH MATH
                        const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        const isPinch = dist < 0.05;

                        // 3. UPDATE BRIDGE (Map 0..1 to -1..1)
                        window.BRIDGE.active = true;
                        window.BRIDGE.x = (rawX * 2) - 1; 
                        window.BRIDGE.y = -(rawY * 2) + 1; // Invert Y for 3D
                        window.BRIDGE.pinch = isPinch;

                        // 4. UPDATE DEBUGGER UI
                        marker.style.display = 'block';
                        marker.style.left = (rawX * 100) + '%';
                        marker.style.top = (rawY * 100) + '%';
                        if(isPinch) marker.style.borderColor = 'yellow';
                        else marker.style.borderColor = 'red';

                        document.getElementById('d-source').innerText = "CAMERA HAND";
                        document.getElementById('d-x').innerText = window.BRIDGE.x.toFixed(2);
                        document.getElementById('d-y').innerText = window.BRIDGE.y.toFixed(2);
                        document.getElementById('d-pinch').innerText = isPinch ? "YES" : "NO";
                        document.getElementById('d-status').innerText = "TRACKING";
                        document.getElementById('d-status').style.color = "#00ff00";

                    } else {
                        // NO HAND
                        window.BRIDGE.active = false;
                        marker.style.display = 'none';
                        document.getElementById('d-source').innerText = "SEARCHING...";
                        document.getElementById('d-status').innerText = "NO HAND";
                        document.getElementById('d-status').style.color = "orange";
                    }
                });

                const camera = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 640, height: 480
                });
                
                await camera.start();

            } catch(e) {
                console.error(e);
                debugStatus.innerText = "CAMERA ERROR";
                debugStatus.style.color = "red";
                alert("Camera Error. Using Mouse Mode.");
            }
        }
    </script>

    <script type="importmap">
        { "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // SETTINGS
        const COUNT = 15000;
        const MAGNITUDE = 50; // Size of the particle world
        
        let scene, camera, renderer, particles;
        let positions, targetPositions;
        let mouse = new THREE.Vector2();

        init();
        animate();

        function init() {
            // Hook up Bridge
            window.BRIDGE.setShape = calculateShape;

            scene = new THREE.Scene();
            
            // CAMERA FAR BACK to see everything
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 60; 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            createParticles();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.addEventListener('mousemove', (e) => {
                // Update mouse fallback
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(COUNT * 3);
            targetPositions = new Float32Array(COUNT * 3);
            const colors = new Float32Array(COUNT * 3);
            const color = new THREE.Color();

            for(let i=0; i<COUNT; i++) {
                positions[i*3] = (Math.random()-0.5) * MAGNITUDE * 2;
                positions[i*3+1] = (Math.random()-0.5) * MAGNITUDE * 2;
                positions[i*3+2] = (Math.random()-0.5) * MAGNITUDE * 2;

                color.setHSL(Math.random(), 0.8, 0.5);
                colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Simple Dot Texture
            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#fff'; 
            ctx.beginPath(); ctx.arc(16,16,10,0,Math.PI*2); ctx.fill();
            const tex = new THREE.CanvasTexture(cvs);

            const material = new THREE.PointsMaterial({
                size: 0.5, map: tex, vertexColors: true, 
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            calculateShape('globe');
        }

        function calculateShape(type) {
            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                let x,y,z;
                
                // MATH SHAPES
                if(type === 'globe') {
                    const phi = Math.acos(-1 + (2*i)/COUNT);
                    const theta = Math.sqrt(COUNT * Math.PI) * phi;
                    x = 15 * Math.cos(theta) * Math.sin(phi);
                    y = 15 * Math.sin(theta) * Math.sin(phi);
                    z = 15 * Math.cos(phi);
                } else if(type === 'heart') {
                    const t = i*0.1;
                    x = 20 * Math.pow(Math.sin(t), 3) * 0.7;
                    y = (13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t)) * 0.7;
                    z = (Math.random()-0.5) * 5;
                } else if(type === 'saturn') {
                    if(i < COUNT*0.7) {
                        const phi = Math.acos(-1 + (2*i)/(COUNT*0.7));
                        const theta = Math.sqrt(COUNT*0.7 * Math.PI) * phi;
                        x=8*Math.cos(theta)*Math.sin(phi); y=8*Math.sin(theta)*Math.sin(phi); z=8*Math.cos(phi);
                    } else {
                        const a = Math.random()*6.28; const r = 12+Math.random()*6;
                        x=r*Math.cos(a); z=r*Math.sin(a); y=(Math.random()-0.5);
                    }
                } else if(type === 'helix') {
                    const t = i*0.05;
                    x=6*Math.cos(t); z=6*Math.sin(t); y=(i*0.1)-20;
                    if(i%2==0){ x=6*Math.cos(t+3.14); z=6*Math.sin(t+3.14); }
                }

                targetPositions[idx] = x;
                targetPositions[idx+1] = y;
                targetPositions[idx+2] = z;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // 1. GET TARGET COORDINATES
            let tx, ty;
            const isHand = window.BRIDGE.active;
            const isPinch = window.BRIDGE.pinch;

            if(isHand) {
                // Hand Logic: Map -1..1 range to World Size (e.g. -30 to 30)
                tx = window.BRIDGE.x * 30;
                ty = window.BRIDGE.y * 30;
                
                // Update Debugger to prove loop is running
                const debugEl = document.getElementById('d-source');
                if(debugEl.innerText !== "CAMERA HAND") debugEl.innerText = "CAMERA HAND";
            } else {
                // Mouse Fallback
                tx = mouse.x * 30;
                ty = mouse.y * 30;
                
                const debugEl = document.getElementById('d-source');
                if(debugEl.innerText === "SEARCHING...") debugEl.innerText = "MOUSE MODE";
            }

            const p = particles.geometry.attributes.position.array;

            // 2. MOVE PARTICLES
            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                let px = p[idx], py = p[idx+1], pz = p[idx+2];
                let targetX = targetPositions[idx];
                let targetY = targetPositions[idx+1];
                let targetZ = targetPositions[idx+2];

                // Calculate Distance to Hand/Mouse
                const dx = px - tx;
                const dy = py - ty;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // --- GESTURE PHYSICS ---
                if(isPinch && dist < 20) {
                    // EXPLODE (High strength)
                    const force = (20 - dist) * 0.5;
                    targetX += dx * force; 
                    targetY += dy * force;
                    targetZ += (Math.random()-0.5) * 10;
                } 
                else if (!isPinch && dist < 15) {
                    // ATTRACT (Magnetic Pull)
                    targetX -= dx * 0.1;
                    targetY -= dy * 0.1;
                    targetZ += Math.sin(i)*0.5; // Swirl
                }

                // Smoothly move to calculated target
                p[idx] += (targetX - px) * 0.1;
                p[idx+1] += (targetY - py) * 0.1;
                p[idx+2] += (targetZ - pz) * 0.1;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
