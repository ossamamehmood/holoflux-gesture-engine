<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Particles - DEBUG MODE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; user-select: none; }
        
        /* THE CANVAS */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* DEBUG CONSOLE (Top Left) */
        #debug-console {
            position: absolute; top: 10px; left: 10px; width: 300px; max-height: 200px;
            background: rgba(0,0,0,0.8); border: 1px solid red; color: #0f0;
            font-size: 10px; padding: 10px; overflow-y: auto; z-index: 1000;
            pointer-events: none; white-space: pre-wrap;
        }

        /* CAMERA BOX (Fixed Position, Always Visible) */
        #video-container {
            position: absolute; bottom: 20px; right: 20px; 
            width: 240px; height: 180px; 
            border: 2px solid #555; background: #222;
            z-index: 1000; border-radius: 8px; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        
        #video-feed {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); /* Mirror */
        }
        
        /* Placeholder text inside camera box */
        #cam-status { position: absolute; color: white; font-size: 12px; text-align: center; }

        /* UI CONTROLS */
        #ui-layer {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            z-index: 100; display: flex; gap: 10px;
        }

        button {
            background: rgba(0,0,0,0.5); border: 1px solid cyan; color: cyan;
            padding: 10px 20px; border-radius: 20px; cursor: pointer; text-transform: uppercase;
        }
        button:hover { background: cyan; color: black; }

        /* START BUTTON OVERLAY */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #start-btn { font-size: 20px; padding: 20px 50px; border: 2px solid cyan; }
    </style>
</head>
<body>

    <div id="debug-console">System Log Initialized...<br></div>

    <div id="overlay">
        <h1 style="color:white; margin-bottom: 20px;">PARTICLE SYSTEM</h1>
        <button id="start-btn">CLICK TO START CAMERA</button>
        <p style="color: #888; margin-top: 10px;">(Must be HTTPS or Localhost)</p>
    </div>

    <div id="video-container">
        <span id="cam-status">Camera Off</span>
        <video id="video-feed" playsinline muted autoplay></video>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <button onclick="morphTo('sphere')">Globe</button>
        <button onclick="morphTo('heart')">Heart</button>
        <button onclick="morphTo('saturn')">Saturn</button>
        <button onclick="toggleExplosion()">ðŸ’¥ Explode</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CUSTOM LOGGER ---
        const debugBox = document.getElementById('debug-console');
        function log(msg, isError = false) {
            const line = document.createElement('div');
            line.textContent = `> ${msg}`;
            if(isError) line.style.color = 'red';
            debugBox.appendChild(line);
            debugBox.scrollTop = debugBox.scrollHeight;
            console.log(msg);
        }
        window.onerror = function(msg, source, lineno) {
            log(`CRITICAL ERROR: ${msg} (Line ${lineno})`, true);
        };

        // --- GLOBAL VARS ---
        let handLandmarker;
        const video = document.getElementById("video-feed");
        const camStatus = document.getElementById("cam-status");
        
        // --- 1. THREE.JS SETUP ---
        const PARTICLE_COUNT = 30000; // Reduced slightly for safety
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Cursor Ring
        const cursorMesh = new THREE.Mesh(
            new THREE.RingGeometry(0.5, 0.7, 32),
            new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide })
        );
        scene.add(cursorMesh);

        // Post Processing
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

        // Shaders
        const vertexShader = `
            uniform float uTime;
            uniform float uMorph;
            uniform vec3 uMouse;
            uniform float uInteractStrength;
            attribute vec3 positionTarget;
            attribute float sizeRandom;
            varying vec3 vColor;
            
            // Fast Noise
            float rand(vec2 co){ return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453); }

            void main() {
                vec3 pos = mix(position, positionTarget, uMorph);
                
                // Simple Noise Movement
                float n = sin(pos.y * 0.1 + uTime) * 0.2;
                pos.x += n; 

                // Interaction
                float dist = distance(pos, uMouse);
                if(dist < 6.0) {
                    vec3 dir = normalize(pos - uMouse);
                    pos += dir * (6.0 - dist) * uInteractStrength;
                }

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = (80.0 * sizeRandom) / -mvPosition.z;
                
                vColor = mix(vec3(0.2, 0.6, 1.0), vec3(1.0, 0.2, 0.5), sizeRandom);
            }
        `;
        const fragmentShader = `
            varying vec3 vColor;
            void main() {
                float r = distance(gl_PointCoord, vec2(0.5));
                if (r > 0.5) discard;
                gl_FragColor = vec4(vColor, 1.0 - r*2.0);
            }
        `;

        // Particles
        const geometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(PARTICLE_COUNT * 3);
        const targetArray = new Float32Array(PARTICLE_COUNT * 3);
        const randArray = new Float32Array(PARTICLE_COUNT);

        for(let i=0; i<PARTICLE_COUNT; i++){
            posArray[i*3] = (Math.random()-0.5)*20;
            posArray[i*3+1] = (Math.random()-0.5)*20;
            posArray[i*3+2] = (Math.random()-0.5)*20;
            targetArray[i*3] = posArray[i*3];
            targetArray[i*3+1] = posArray[i*3+1];
            targetArray[i*3+2] = posArray[i*3+2];
            randArray[i] = Math.random();
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geometry.setAttribute('positionTarget', new THREE.BufferAttribute(targetArray, 3));
        geometry.setAttribute('sizeRandom', new THREE.BufferAttribute(randArray, 1));

        const material = new THREE.ShaderMaterial({
            vertexShader, fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 },
                uMouse: { value: new THREE.Vector3(999,999,999) },
                uInteractStrength: { value: 1.0 }
            },
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        scene.add(new THREE.Points(geometry, material));

        // Shapes Logic
        const shapes = {
            sphere: () => {
                const arr = new Float32Array(PARTICLE_COUNT*3);
                for(let i=0; i<PARTICLE_COUNT; i++){
                    const u=Math.random(), v=Math.random();
                    const t=2*Math.PI*u, p=Math.acos(2*v-1);
                    const r=10;
                    arr[i*3]=r*Math.sin(p)*Math.cos(t);
                    arr[i*3+1]=r*Math.sin(p)*Math.sin(t);
                    arr[i*3+2]=r*Math.cos(p);
                } return arr;
            },
            heart: () => { // Simplified heart
                const arr = new Float32Array(PARTICLE_COUNT*3);
                for(let i=0; i<PARTICLE_COUNT; i++){
                    let t = Math.random()*Math.PI*2, s = Math.random();
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                    arr[i*3]=x*0.5*s; arr[i*3+1]=y*0.5*s; arr[i*3+2]=(Math.random()-0.5)*4;
                } return arr;
            },
            saturn: shapes_saturn, // Defined below to save space
        };

        function shapes_saturn() {
             const arr = new Float32Array(PARTICLE_COUNT*3);
             for(let i=0; i<PARTICLE_COUNT; i++){
                 if(i<PARTICLE_COUNT*0.6) { // Planet
                    const u=Math.random(), v=Math.random();
                    const t=2*Math.PI*u, p=Math.acos(2*v-1);
                    arr[i*3]=7*Math.sin(p)*Math.cos(t);
                    arr[i*3+1]=7*Math.sin(p)*Math.sin(t);
                    arr[i*3+2]=7*Math.cos(p);
                 } else { // Rings
                    const t = Math.random()*Math.PI*2;
                    const r = 10 + Math.random()*8;
                    arr[i*3]=r*Math.cos(t); arr[i*3+1]=(Math.random()-0.5); arr[i*3+2]=r*Math.sin(t);
                 }
             } return arr;
        }

        window.morphTo = (name) => {
            if(!shapes[name]) return;
            log(`Morphing to ${name}`);
            const newPos = shapes[name]();
            geometry.attributes.positionTarget.set(newPos);
            geometry.attributes.positionTarget.needsUpdate = true;
            let val = { v: 0 };
            function anim() {
                val.v += 0.02;
                material.uniforms.uMorph.value = val.v;
                if(val.v < 1) requestAnimationFrame(anim);
            }
            anim();
        };
        
        window.toggleExplosion = () => {
             log("Explosion Triggered");
             material.uniforms.uInteractStrength.value = -5.0;
             setTimeout(() => material.uniforms.uInteractStrength.value = 1.0, 500);
        };

        // --- 2. CAMERA INITIALIZATION ---
        async function startCamera() {
            const btn = document.getElementById('start-btn');
            btn.innerText = "REQUESTING ACCESS...";
            log("Attempting to access camera...");

            // Check if secure context
            if (!window.isSecureContext) {
                log("ERROR: App is not in Secure Context (HTTPS/Localhost). Camera will fail.", true);
                alert("ERROR: You must run this on Localhost or HTTPS (Vercel/Netlify).");
                return;
            }

            try {
                // 1. Get Stream
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 320, height: 240, facingMode: "user" } 
                });
                
                log("Camera Access GRANTED.");
                video.srcObject = stream;
                
                // 2. Wait for video data
                await new Promise((resolve) => {
                    video.onloadeddata = () => {
                        log("Video Data Loaded.");
                        resolve();
                    };
                });
                
                video.play();
                camStatus.style.display = 'none'; // Hide "Camera Off" text
                document.getElementById('video-container').style.border = "2px solid #0f0"; // Green border
                
                // 3. Load AI
                log("Loading AI Model...");
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1,
                    minHandDetectionConfidence: 0.3
                });
                
                log("AI Model Loaded. Tracking Active.");
                document.getElementById('overlay').style.display = 'none'; // Remove start screen
                predictWebcam();

            } catch (err) {
                log(`FAILURE: ${err.message}`, true);
                log(`Full Error: ${err}`, true);
                btn.innerText = "FAILED - CHECK LOGS";
                btn.style.borderColor = "red";
                btn.style.color = "red";
            }
        }

        // --- 3. TRACKING LOOP ---
        let targetX = 0, targetY = 0, currentX = 0, currentY = 0;

        async function predictWebcam() {
            if (handLandmarker && video.currentTime !== 0) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                if (results.landmarks.length > 0) {
                    const p = results.landmarks[0][8]; // Index Tip
                    // Log only every 100 frames to save spam, or just use visual
                    targetX = (1 - p.x) * 40 - 20; 
                    targetY = -(p.y) * 30 + 15;
                    cursorMesh.visible = true;
                    document.getElementById('video-container').style.borderColor = "#00ff00"; // Green when tracking
                } else {
                    cursorMesh.visible = false;
                    document.getElementById('video-container').style.borderColor = "#555"; // Grey when lost
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        // --- 4. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value = performance.now() / 1000;
            
            // Lerp Mouse
            currentX += (targetX - currentX) * 0.1;
            currentY += (targetY - currentY) * 0.1;
            material.uniforms.uMouse.value.set(currentX, currentY, 0);
            
            cursorMesh.position.set(currentX, currentY, 5);
            
            composer.render();
        }

        // Bind
        document.getElementById('start-btn').addEventListener('click', startCamera);
        animate(); // Start rendering loop immediately
        log("System Ready. Waiting for user start.");

        // Mouse Fallback
        window.addEventListener('mousemove', (e) => {
             if(!handLandmarker) {
                 targetX = (e.clientX/window.innerWidth)*40 - 20;
                 targetY = -(e.clientY/window.innerHeight)*30 + 15;
                 cursorMesh.visible = true;
             }
        });

    </script>
</body>
</html>
